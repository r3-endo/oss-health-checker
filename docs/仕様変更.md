````markdown
## 目的（Why）

現状のスコアリングやトレンド計算は解釈が混ざりやすく、CTO/シニアの意思決定に必要な「一次情報」が前面に出ていない。  
まずは **GitHubから取得できる“加工の少ない事実”を一覧で比較できる** 状態を作り、ユーザー要望が出てから加工（スコア/トレンド/差分）を段階的に追加する。

---

## スコープ（What）

カテゴリ別（LLM / Backend / Frontend）のダッシュボードを維持しつつ、表の表示項目を「一次情報」に絞る。

### 表示項目（必須）

1. **主要なメンテ者（org? 個人?）**
2. **Open Issues 数**
3. **Open PR 数**
4. **main(default branch) への最終コミット日時**
5. **Star 数**

### 非目標（Non-Goals）

- health score / status の表示・計算
- 30日トレンド、前日差分などの加工指標
- 依存解析、npm/maven/pypi/brew指標
- 認証・課金・通知

---

## 仕様詳細（GitHubから何を取るか）

### 1) 主要メンテ者（org/個人）の定義（Phase 1.5 での簡易版）

以下の優先順で決定し、**「推定」ではなくルールを明確化**する。

- `repository.owner` を主要メンテ者として表示
  - `owner.type` が `"Organization"` なら `Org`
  - `owner.type` が `"User"` なら `Individual`
- 表示形式：`owner.login` + `owner.type(Org/Individual)` バッジ

> NOTE: コラボレータ/メンテ権限の厳密判定はGitHub権限が必要で複雑。Phase 1.5 では owner を「主要メンテ者（運営主体）」として扱う。

---

### 2) Open Issues 数

GitHub REST v3 の `repository.open_issues_count` は **PRも含む** ため、そのまま使うと誤解を招く。

**必須方針**：

- Issues と PR を分けて取得する

実装案（REST Search API）：

- Open Issues: `GET /search/issues?q=repo:{owner}/{repo}+type:issue+state:open`
- Open PRs: `GET /search/issues?q=repo:{owner}/{repo}+type:pr+state:open`

レスポンスの `total_count` を使用。

> NOTE: Search API は rate limit が厳しいため、複数リポに対してはキャッシュ/バッチ/間引きが必要（後述）。

---

### 3) main(default branch)への最終コミット日時

- `GET /repos/{owner}/{repo}` で `default_branch` を取得
- `GET /repos/{owner}/{repo}/commits/{default_branch}` で最新コミットを取得
- 取得する日時：`commit.committer.date`（または author date。どちらを使うか固定）
- 表示は `YYYY-MM-DD` or `YYYY-MM-DD HH:mm`（UIに合わせる）

---

### 4) Star 数

- `GET /repos/{owner}/{repo}` の `stargazers_count`

---

## API設計（Backend）

### GET /api/categories

従来通り（カテゴリ一覧）

### GET /api/categories/:slug

レスポンスを「一次情報」中心に変更：

```json
{
  "name": "Large Language Models",
  "repositories": [
    {
      "owner": {
        "login": "langchain-ai",
        "type": "Organization"
      },
      "name": "langchain",
      "github": {
        "stars": 12345,
        "openIssues": 111,
        "openPRs": 22,
        "lastCommitToDefaultBranchAt": "2026-02-13T01:23:45Z",
        "defaultBranch": "main"
      },
      "links": {
        "repo": "https://github.com/langchain-ai/langchain"
      }
    }
  ]
}
```
````

### エラー/未取得時の扱い（必須）

`N/A` で潰さず、状態を区別する：

- `dataStatus: "ok" | "pending" | "rate_limited" | "error"`
- `errorMessage`（UIには短く）

---

## Rate Limit 対策（必須）

Search API を各リポで2回（issue/pr）叩くとすぐ枯れるため、最低限の対策が必要。

### 必須要件

- サーバ側でキャッシュ（例：TTL 10〜60分）
- 同一リポへの同時リクエストは in-flight dedupe
- 失敗時は過去キャッシュを返す（stale-while-revalidate でも可）

> 認証なしで提供するなら、特に重要。

---

## フロントエンド（UI）

カテゴリタブは維持。テーブル列を次に変更：

- Repository（owner/name）
- Maintainer（owner.type バッジ付き）
- Stars
- Open Issues
- Open PRs
- Last Commit (default branch)

要件：

- ローディング状態
- エラー状態（rate limit含む）
- 最終更新時刻（"Updated X min ago"）をテーブル右上に小さく表示

---

## 受け入れ基準（Acceptance Criteria）

- 3カテゴリでシード済みリポジトリが表示される
- 各行に以下が揃う：owner(org/user), stars, open issues, open PRs, last commit
- Issue と PR が混同されていない（Search API total_count を使用）
- Rate limit で落ちても UI が「理由付き」で耐える
- 既存の手動登録機能に退行がない（カテゴリ表示とは別系統で動作）

---

## 実装上の制約（Architecture）

- ルートハンドラにロジックを書かない
- GitHub API 呼び出しは infrastructure adapter に閉じる
- カテゴリ取得・集計は application service へ
- DTO を固定し、将来の加工指標を追加できるように `github` オブジェクトに集約

---

## Deliverables

- Backend: GitHub adapter への Search API 対応、キャッシュ層追加、カテゴリ詳細API更新
- Frontend: テーブル列変更、dataStatus 表示、最終更新時刻表示
- テスト: APIレスポンスの shape と、Issue/PR分離の検証

```

### 補足（実装で迷いやすいポイント）
- `open_issues_count` は PR を含むため **使わない**（もしくは補助表示に留める）
- Search API の rate limit を前提に「キャッシュなし」は避ける
- 「主要メンテ者」は Phase 1.5 では owner で割り切る（権限判定はスコープ外）
```
